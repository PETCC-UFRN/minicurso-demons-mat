<!DOCTYPE html>
<html>
    <head>
        <title>Minicurso de Linux e Git</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="./assets/css/styles.css">
        <link rel="stylesheet" href="/minicurso-demons-mat/assets/css/syntax.css">
        <link rel="icon" href="https://i.ibb.co/RD7XwYH/pet-logo.png" type="image/png">
    </head>
    <body class="layoutGit">
        <header>
    <nav class="navgit">
        <ul class="listaNavegacao">
            <li>
                <a href="index" style="text-decoration:none;">/home</a>
            </li>
            <li>
                <a href="aulas" style="text-decoration:none;">/aulas</a>
            </li> 
            <li>
                <a href="sobre" style="text-decoration:none;">/sobre</a>
            </li>
        </ul>
    </nav>
</header>

        <div>
            <main>
                <div id="sumario" class="sumario-git">
    <h1>Sumário</h1>
    <details>
        <summary><a href="#introdução-ao-curso">Introdução</a></summary>
    <ul>
        <li><a href="#matemática-e-computação">Matemática e computação</a></li>
    </ul>
    </details>
    <details>
        <summary><a href="#lógica">Lógica</a></summary>
        <ul>
            <li><a href="#clareza-e-precisão-no-código">Clareza e precisão no código</a></li>
            <li><a href="#depuração-eficaz">Depuração eficaz</a></li>
            <li><a href="#design-de-algoritmos">Design de algoritmos</a></li>
            <li><a href="#verificação-e-testes">Verificação e testes</a></li>
        </ul>
    </details>
    <details>
         <summary><a href="#elementos-da-lógica-formal">Elementos da lógica formal</a></summary>
        <ul>
            <li><a href="#proposições">Proprosições</a></li>
            <li><a href="#conectivos-lógicos">Conectivos lógicos</a>
                <ul> 
                    <li><a href="#negação">Negação</a></li>
                    <li><a href="#conjunção">Conjunção</a></li>
                    <li><a href="#disjunção">Disjunção</a></li>
                    <li><a href="#implicação">Implicação</a></li>
                    <li><a href="#bi-implicação">Bi-implicação</a></li>
                    <li><a href="#contradição">Contradição</a></li>
                </ul>
            </li>
        </ul>
    </details>
  <button class="toggle-button" id="toggle-button">
  
      Esconder Sumário
  
  </button>
</div>

<!--<div style="text-align: center;"> <img alt="Meme muito engraçado sobre arquivos do sistema" src="assets/images/funny-math-meme.png" width="50%">
</div>
-->

<p><br /></p>

<h1 id="dia-1--benefícios-da-lógica-na-programação">Dia 1 | Benefícios da Lógica na Programação</h1>

<h2 id="introdução-ao-curso">Introdução ao curso</h2>
<p>Olá a todos! Sejam bem-vindos ao primeiro dia do nosso minicurso de Introdução às Demonstrações Matemáticas. Neste curso iremos buscar entender qual a ligação entre a Matemática e a Computação, como as Demonstrações Matemáticas são parte essencial da nossa área e quais benefícios podemos tirar delas!</p>

<h3 id="matemática-e-computação">Matemática e Computação</h3>
<p>A computação tem suas raízes profundamente entrelaçadas com a matemática, visto que toda a sua base teórica veio do trabalho de diversos matemáticos ao longo dos últimos séculos, desde a criação do primeiro algoritmo feito por Ada Lovelace, até as definições formais de computadores, e o significado  “ser computável” feitas por Alan Turing e Alonzo Church. Além disso, figuras como George Boole, criador da álgebra booleana, e John Von Neumann, com sua arquitetura de computadores, mostraram como conceitos puramente matemáticos podem influenciar a nossa área.</p>

<h2 id="lógica">Lógica</h2>
<p>Para começarmos a entender mais profundamente a influência da matemática na programação, e como conceitos matemáticos se relacionam com a área da Computação, precisamos ser introduzidos à Lógica, que estrutura toda a matemática que conhecemos, e quais seus benefícios na nossa área.</p>

<h3 id="clareza-e-precisão-no-código">Clareza e Precisão no Código</h3>
<p>A lógica nos permite estruturar soluções de forma clara e concisa. Ao aplicar princípios lógicos, podemos garantir que cada linha de código tenha um propósito bem definido e que o fluxo do programa seja facilmente compreendido.</p>
<ul>
  <li>Estruturas de Controle: As estruturas de controle, como <code class="language-plaintext highlighter-rouge">if/else</code>, <code class="language-plaintext highlighter-rouge">while</code> e <code class="language-plaintext highlighter-rouge">for</code>, são a espinha dorsal de qualquer programa. Elas dependem intrinsecamente de condições lógicas bem definidas para guiar o fluxo de execução. Uma condição lógica mal formulada pode levar a um comportamento inesperado ou a erros difíceis de rastrear.</li>
  <li>Pensamento Algorítmico: A lógica nos treina a pensar de forma algorítmica, ou seja, a decompor um problema complexo em passos menores e mais gerenciáveis. Cada passo é uma decisão lógica que contribui para a solução geral.</li>
</ul>

<h4 id="exemplo">Exemplo</h4>
<p>Imagine que queremos criar um programa que verifica se um aluno foi aprovado ou reprovado em uma disciplina. Para ser aprovado, o aluno precisa ter nota maior ou igual a 60 <strong>E</strong> frequência maior ou igual a 75%. Se apenas uma dessas condições não for atendida, ele será reprovado.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Lógica bem definida
nota = 65
frequencia = 80

if nota &gt;= 60 and frequencia &gt;= 75:
    print("Aluno Aprovado!")
else:
    print("Aluno Reprovado!")

# Saída: Aluno Reprovado!
</code></pre></div></div>

<p>Agora, vamos ver um exemplo de como uma lógica mal definida pode levar a erros.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Lógica mal definida
nota = 70
frequencia = 70

if nota &gt;= 70 or frequencia &gt;= 75:
    print("Aluno Aprovado!")
else:
    print("Aluno Reprovado!")

# Saída: Aluno Aprovado! (Incorreto, pois a frequência é menor que 75)
</code></pre></div></div>
<p>Nesse segundo exemplo, a utilização do operador ‘ou’ (OR) em vez do ‘e’ (AND) resultou em uma aprovação indevida. Isso demonstra como a precisão na lógica é crucial para o comportamento correto do programa.</p>

<p>Portanto, uma simples mudança no código pode fazer com que os resultados mudem drasticamente. Por mais que seja um exemplo bobinho, é importante que o programador, ao escrever seu código, saiba exatamente como ele deve se comportar.</p>

<h3 id="depuração-eficaz">Depuração Eficaz</h3>
<p>Mesmo que você sempre aplique boas técnicas de programação, é comum que algum ponto “passe batido”, ou você pode ficar responsável por revisar algum código que não tenha sido bem escrito. É aí que entra o processo de depuração: Seguir o fluxo do código para identificar em qual ponto o erro ocorreu, e corrigi-lo. Vejamos um exemplo:</p>

<h4 id="exemplo-1">Exemplo</h4>
<p>Suponha que temos um programa que calcula o dobro do módulo de um número.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def calcular_dobro_modulo(numero):
    if numero &gt; 0:
        numero = numero *2
        return numero
    else:
        numero = numero *-1
        numero = numero +2
        return numero
    
print(calcular_dobro_modulo(5))   # Output: 10
print(calcular_dobro_modulo(-5))  # Output: 7
</code></pre></div></div>

<p>10 é o dobro do módulo de 5, então nosso código funciona para essa entrada. Porém, 7 não é o dobro do módulo de -5. Vamos investigar:</p>

<ul>
  <li>Primeiro, verificamos a entrada: <code class="language-plaintext highlighter-rouge">numero = -5</code>;</li>
  <li>Entramos no <code class="language-plaintext highlighter-rouge">if</code>;
    <ul>
      <li>A condição <code class="language-plaintext highlighter-rouge">numero &gt; 0</code> é <code class="language-plaintext highlighter-rouge">False</code>;</li>
    </ul>
  </li>
  <li>Saímos do <code class="language-plaintext highlighter-rouge">if</code> e entramos no <code class="language-plaintext highlighter-rouge">else</code>;
    <ul>
      <li>Então a operação <code class="language-plaintext highlighter-rouge">numero = numero * -1</code> é executada;</li>
      <li>Temos <code class="language-plaintext highlighter-rouge">numero = 5 * -1 = 5</code>;</li>
      <li>A operação <code class="language-plaintext highlighter-rouge">numero = numero+2 = 7</code> é executada</li>
    </ul>
  </li>
</ul>

<p><strong>Achamos nosso erro!</strong> No lugar de multiplicar por 2, foi somado 2. Existem muitos motivos que podem ter levado a esse erro, como também existem muitas maneiras de corrigi-lo. A mais simples é trocando o símbolo de soma pelo da multiplicação.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def calcular_dobro_modulo(numero):
    if numero &gt; 0:
        numero = numero *2
        return numero
    else:
        numero = numero *-1
        numero = numero *2
        return numero
    
print(calcular_dobro_modulo(5))   # Output: 10
print(calcular_dobro_modulo(-5))  # Output: 10
</code></pre></div></div>

<p>Mais uma vez, um exemplo simples, mas que mostra que esse tipo de abordagem pode ser útil. Por mais que pareça bobinho, esse tipo de erro de digitação é relativamente comum.</p>

<h3 id="design-de-algoritmos">Design de Algoritmos</h3>
<p>Parte da lógica é fazer as coisas na ordem correta. Portanto, antes de escrever qualquer linha de código, precisamos entender o que o programa deve fazer. A lógica nos permite expressar requisitos e especificações de forma precisa e sem ambiguidades. É a ferramenta fundamental para pensar na sequência de passos que o algoritmo deve seguir, nas decisões que ele precisa tomar e nas repetições necessárias para alcançar o objetivo. No lugar de <strong>programar e pensar</strong> ao mesmo tempo, podemos montar uma solução e só depois partir para o código.</p>

<h4 id="exemplo-2">Exemplo</h4>
<p>Imagine que precisamos criar um algoritmo para encontrar o maior número em uma lista. Como podemos fazer isso?</p>

<ol>
  <li>Precisamos de um lugar para armazenar o maior número que encontramos até agora. Vamos chamá-lo de <code class="language-plaintext highlighter-rouge">maior_numero_encontrado</code>;</li>
  <li>Vamos começar assumindo que o primeiro número da lista é o maior;</li>
  <li>Precisamos olhar cada número na lista, um por um;</li>
  <li>Para cada número, vamos compará-lo com o <code class="language-plaintext highlighter-rouge">maior_numero_encontrado</code>;</li>
  <li>Se o número atual for maior que o <code class="language-plaintext highlighter-rouge">maior_numero_encontrado</code>, então o número atual se torna o novo <code class="language-plaintext highlighter-rouge">maior_numero_encontrado</code>;</li>
  <li>Depois de verificar todos os números, o <code class="language-plaintext highlighter-rouge">maior_numero_encontrado</code> será o maior número da lista.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def encontrar_maior_numero(lista):
    # Assume o primeiro como o maior
    maior_numero_encontrado = lista[0]

    # Itera sobre os elementos da lista
    for numero in lista:
        if numero &gt; maior_numero_encontrado:
            maior_numero_encontrado = numero

    return maior_numero_encontrado

lista = [10, 5, 20, 8, 15]
print(encontrar_maior_numero(lista))
# Saída: 20
</code></pre></div></div>

<h3 id="verificação-e-testes">Verificação e Testes</h3>
<p>Depois de escrever um programa, precisamos ter certeza de que ele funciona como esperado, ou seja, precisamos testá-lo. Esta etapa pode não fazer muito sentido em <em>softwares</em> mais simples (trabalhos da faculdade, por exemplo), mas Aplicações Críticas ou Aplicações Comerciais/Empresariais têm uma tolerância menor a comportamentos inesperados, então a parte de testes acaba tendo uma importância bem maior. A lógica nos ajuda a formular testes que cubram diferentes caminhos de execução do código, validando todas as condições lógicas e ramificações.</p>

<p>O raciocínio lógico nos permite criar casos de teste abrangentes, incluindo:</p>
<ul>
  <li>Casos de Borda (Edge Cases): Valores mínimos e máximos, listas vazias, strings nulas, etc.</li>
  <li>Casos de Sucesso: Entradas que devem produzir o resultado esperado.</li>
  <li>Casos de Falha: Entradas que devem acionar mensagens de erro ou comportamento específico.</li>
</ul>

<h4 id="exemplo-3">Exemplo</h4>
<p>Para a nossa função calcular_dobro, vamos pensar em casos de teste usando a lógica.</p>

<ul>
  <li>Caso de Sucesso (número positivo): Se a entrada é 5, a saída deve ser 10.</li>
  <li>Caso de Sucesso (número negativo): Se a entrada é -5, a saída deve ser -10.</li>
  <li>Caso de Sucesso (zero): Se a entrada é 0, a saída deve ser 0.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def calcular_dobro(numero):
    return numero * 2

# Casos de Teste
assert calcular_dobro(5) == 10, "Erro: 5 * 2 deveria ser 10"
assert calcular_dobro(-5) == -10, "Erro: -5 * 2 deveria ser -10"
assert calcular_dobro(0) == 0, "Erro: 0 * 2 deveria ser 0"

print("Todos os testes passaram para calcular_dobro!")
</code></pre></div></div>

<p>Abordagens de testes guiadas por raciocínio lógico nos permite não apenas verificar se o código funciona para casos óbvios, mas também garantir sua robustez em cenários complexos e nos limites das condições. Testes são, em essência, pequenas demonstrações de que nosso código se comporta conforme o esperado sob certas condições. Eles não provam a ausência de bugs, mas aumentam significativamente a confiança na qualidade e na corretude do software, reduzindo riscos e facilitando a manutenção a longo prazo.
—</p>

<h2 id="elementos-da-lógica-formal">Elementos da Lógica Formal</h2>
<p>Agora que vimos os benefícios práticos da lógica, vamos aprofundar um pouco mais nos conceitos fundamentais. Pois bem! A lógica é o ‘estudo do raciocínio válido e das inferências’. É uma ferramenta poderosa para a dedução, baseada em hipóteses e premissas. Pensar logicamente é algo que fazemos o tempo todo, mesmo sem perceber. Quando tomamos decisões no dia a dia, resolvemos problemas ou argumentamos sobre algo, estamos aplicando a lógica.</p>

<h3 id="proposições">Proposições</h3>
<p>No contexto da lógica formal, um dos blocos construtivos mais básicos são as <strong>proposições</strong>.</p>

<p>Uma proposição é uma <strong>afirmação declarativa que pode ser classificada como verdadeira ou falsa</strong>, mas nunca ambas simultaneamente. É crucial que a afirmação não seja ambígua.</p>

<h4 id="exemplo-4">Exemplo</h4>
<p>Vamos ver alguns exemplos para fixar esse conceito. Para cada frase, digam se é uma proposição e, se for, qual seu valor verdade.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Natal é a capital do Rio Grande do Norte!

Sim, é uma proposição. O valor verdade é Verdadeiro.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Natal não é a capital do Rio Grande do Norte!

Sim, é uma proposição. O valor verdade é Falso.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 + 2 = 5

Sim, é uma proposição. O valor verdade é Falso
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Que horas são?

Não, não é uma proposição. É uma pergunta.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Feche a porta.

Não, não é uma proposição. É uma ordem.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x+3=7.

Não é uma proposição, pois o valor verdade depende do valor de x.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Todo número par é divisível por 2.

Sim, é uma proposição. O valor verdade é Verdadeiro.
</code></pre></div></div>

<ul>
  <li>Se alguns exemplos não ficaram muito claros, não se preocupem, esse tipo de conhecimento vai ser aprimorado com o tempo</li>
  <li><strong>OBS:</strong> É comum usar um símbolo para representar uma proposição. Normalmente, as letras <strong>P</strong> e <strong>Q</strong> são utilizadas, mas isso não significa que outros símbolos não possam ser usados.</li>
</ul>

<h3 id="conectivos-lógicos">Conectivos Lógicos</h3>
<p>As proposições podem ser combinadas para formar proposições mais complexas usando conectivos lógicos. Cada conectivo tem uma regra específica para determinar o valor verdade da proposição composta. Vamos explorar os principais e suas tabelas verdade.</p>

<h4 id="negação">Negação</h4>
<p>A negação de uma proposição simplesmente inverte seu valor verdade. Se <strong>P</strong> é verdadeira, <strong>¬P</strong> é falsa, e vice-versa.</p>

<p><strong>Tabela Verdade</strong>
| P | ¬P |
|—|—|
| V | F |
| F | V |</p>

<ul>
  <li>
    <p>P: ‘O sol é uma estrela.’ (Verdadeiro)</p>
  </li>
  <li>
    <p>¬P: ‘O sol não é uma estrela.’ (Falso)</p>
  </li>
</ul>

<h4 id="conjunção">Conjunção</h4>
<p>A conjunção de duas proposições <strong>P</strong> e <strong>Q</strong> (lê-se <strong>P e Q</strong>) é verdadeira se ambas <strong>P</strong> e <strong>Q</strong> forem verdadeiras. Em todos os outros casos, é falsa.</p>

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>Q</th>
      <th>P ∧ Q</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>F</td>
      <td>F</td>
    </tr>
  </tbody>
</table>

<p>Exemplo prático:</p>

<ul>
  <li>P: ‘Está chovendo.’</li>
  <li>Q: ‘Estou com guarda-chuva.’</li>
  <li>P ∧ Q: ‘Está chovendo e estou com guarda-chuva.’</li>
</ul>

<p>Esta proposição será verdadeira apenas se ambas as condições (chuva e guarda-chuva) forem verdadeiras.</p>

<h4 id="disjunção">Disjunção</h4>
<p>A disjunção de duas proposições <strong>P</strong> e <strong>Q</strong> (lê-se <strong>P ou Q</strong>) é verdadeira se pelo menos uma das proposições <strong>P</strong> ou <strong>Q</strong> for verdadeira. É falsa apenas se ambas <strong>P</strong> e <strong>Q</strong> forem falsas.</p>

<hr />
<h5 id="diferenças-com-o-português">Diferenças com o Português</h5>
<p>É importante lembrar que existe uma certa diferença entre o <strong>“ou” lógico</strong> e o <strong>“ou” cotidiano</strong>. Em português, se dissermos “<em>este ano viajarei para João Pessoa ou Recife</em>”, normalmente queremos dizer que:</p>
<ol>
  <li>Se eu viajar para João Pessoa, então não viajarei para Recife; por outro lado</li>
  <li>Se eu viajar para Recife, então não viajarei para João Pessoa</li>
</ol>

<p>Perceba que, neste caso, fazer uma coisa significa que não farei a outra. Porém, usando conectivos lógicos, as afirmações <strong>1.</strong> e <strong>2.</strong> não seriam, necessariamente, verdadeiras.</p>

<hr />

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>Q</th>
      <th>P ∨ Q</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>V</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>F</td>
      <td>F</td>
      <td>F</td>
    </tr>
  </tbody>
</table>

<p>Exemplo Prático:</p>

<ul>
  <li>
    <p>P: ‘Vou viajar para João Pessoa.’</p>
  </li>
  <li>
    <p>Q: ‘Vou viajar para Recife.’</p>
  </li>
  <li>
    <p>P ∨ Q: ‘Vou viajar para João Pessoa ou vou viajar para Recife.’</p>
  </li>
</ul>

<p>Esta proposição é verdadeira se eu viajar para João Pessoa, viajar para Recife, ou se eu fizer as duas coisas. Só será falsa se eu não viajar para João Pessoa e não viajar para Recife.</p>

<h4 id="implicação">Implicação</h4>
<p>A implicação de <strong>P</strong> para <strong>Q</strong> (lê-se ‘<strong>Se P então Q</strong>’) é falsa apenas quando <strong>P</strong> é verdadeira e <strong>Q</strong> é falsa. Em todos os outros casos, é verdadeira.”</p>

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>Q</th>
      <th>P ⟹ Q</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>F</td>
      <td>F</td>
      <td>V</td>
    </tr>
  </tbody>
</table>

<p>Exemplo Prático:</p>

<ul>
  <li>
    <p>P: ‘Chove.’</p>
  </li>
  <li>
    <p>Q: ‘A rua fica molhada.’</p>
  </li>
  <li>
    <p>“P ⟹ Q: ‘Se chover, então a rua fica molhada.’</p>
  </li>
</ul>

<p>Esta proposição só será falsa se chover (<strong>P</strong> verdadeira) e a rua não ficar molhada (<strong>Q</strong> falsa), o que é um cenário inconsistente com o senso comum. Se não chover (<strong>P</strong> falsa), a proposição é considerada verdadeira, independentemente se a rua está molhada ou não (pode ter sido lavada, por exemplo).</p>

<h5 id="valor-verdade-por-vacuidade">Valor Verdade por Vacuidade:</h5>

<p>Existe um conceito interessante na lógica chamado verdade por vacuidade. Uma proposição condicional <strong>Se P então Q</strong> é considerada verdadeira se a premissa <strong>P</strong> for falsa, independentemente do valor verdade de <strong>Q</strong>. Por exemplo, ‘<em>Se 2 + 2 = 5, então o céu é verde</em>’. Como a premissa ‘<em>2 + 2 = 5</em>’ é falsa, a proposição inteira é verdadeira, mesmo que ‘<em>o céu é verde</em>’ seja falsa. Isso pode parecer contraintuitivo, mas é uma <strong>convenção</strong> importante na lógica formal.</p>

<h4 id="bi-implicação">Bi-implicação</h4>
<p>A bi-implicação de <strong>P</strong> e <strong>Q</strong> (lê-se ‘<strong>P se e somente se Q</strong>’) é verdadeira se P e Q tiverem o mesmo valor verdade (ambas verdadeiras ou ambas falsas). É falsa se tiverem valores verdade diferentes.”</p>

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>Q</th>
      <th>P ⟺ Q</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>V</td>
      <td>V</td>
    </tr>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>F</td>
      <td>V</td>
    </tr>
  </tbody>
</table>

<p>Exemplo Prático:</p>

<ul>
  <li>
    <p>P: ‘Você passa na disciplina.’</p>
  </li>
  <li>
    <p>Q: ‘Você tira nota maior ou igual a 7.’</p>
  </li>
  <li>
    <p>P ⟺ Q: ‘Você passa na disciplina se e somente se tirar nota maior ou igual a 6.’</p>
  </li>
  <li>
    <p>Isso significa que passar na disciplina está diretamente ligado a tirar nota 6 ou mais. Se você passar, significa que tirou nota 6 ou mais, e vice-versa. Se uma é verdadeira e a outra falsa, a bi-implicação é falsa.”</p>
  </li>
</ul>

<h4 id="contradição">Contradição</h4>
<p>Uma contradição é uma proposição que é sempre falsa, independentemente do valor verdade de suas proposições componentes. Por exemplo, ‘<em>Está chovendo <strong>e</strong> não está chovendo</em>’.</p>

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>¬P</th>
      <th>P ∨ ¬P</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>F</td>
    </tr>
  </tbody>
</table>

<h4 id="tautologia">Tautologia:</h4>
<p>Uma tautologia é uma proposição que é sempre verdadeira, independentemente do valor verdade de suas proposições componentes. Por exemplo, ‘<em>Está chovendo <strong>ou</strong> não está chovendo</em>’.</p>

<p><strong>Tabela Verdade</strong></p>

<table>
  <thead>
    <tr>
      <th>P</th>
      <th>¬P</th>
      <th>P ∨ ¬P</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V</td>
      <td>F</td>
      <td>V</td>
    </tr>
    <tr>
      <td>F</td>
      <td>V</td>
      <td>V</td>
    </tr>
  </tbody>
</table>

            </main>
            <script src="./assets/js/sumario_script.js"></script>
        </div>
    </body>
</html>
